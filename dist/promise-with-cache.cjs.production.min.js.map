{"version":3,"file":"promise-with-cache.cjs.production.min.js","sources":["../src/tools.ts","../src/index.ts"],"sourcesContent":["/**\n * 生成uuid\n */\nexport const uuidGenerate = () => {\n  let timestamp = new Date().getTime();\n  let perforNow =\n    (typeof performance !== 'undefined' &&\n      performance.now &&\n      performance.now() * 1000) ||\n    0;\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    let random = Math.random() * 16;\n    if (timestamp > 0) {\n      random = (timestamp + random) % 16 | 0;\n      timestamp = Math.floor(timestamp / 16);\n    } else {\n      random = (perforNow + random) % 16 | 0;\n      perforNow = Math.floor(perforNow / 16);\n    }\n    return (c === 'x' ? random : (random & 0x3) | 0x8).toString(16);\n  });\n};\n","import { uuidGenerate } from './tools';\ninterface RequestCallback {\n  onSuccess: (data: any) => void;\n  onError: (error: any) => void;\n}\n\n// 存放等待状态的请求回调\nconst callbackMap = new Map<string, RequestCallback[]>();\n\n// 异步任务状态缓存\nconst statusMap = new Map<string, 'pending' | 'complete'>();\n\n// 实际数据缓存\nconst cacheMap = new Map<string, Record<string, any>>();\n\nclass CachePromise<T = any> {\n  private promiseFunc: () => Promise<T>;\n\n  private cacheKey: string;\n\n  private generateCacheKey() {\n    return uuidGenerate();\n  }\n\n  /**\n   * 静态方法-指定key清空缓存，如果不传则全部清空\n   */\n  static clearCache(cacheKey?: string) {\n    if (cacheKey == void 0) {\n      callbackMap.clear();\n      statusMap.clear();\n      cacheMap.clear();\n    } else {\n      callbackMap.delete(cacheKey);\n      statusMap.delete(cacheKey);\n      cacheMap.delete(cacheKey);\n    }\n  }\n\n  /**\n   * 并发异步任务缓存\n   *\n   * @param promiseFunc 返回值是个promise的函数\n   * @param cacheKey 缓存key，如果不指定静态cacheKey的话，那只能实例化一次（缓存key会在实例化生成）\n   */\n  constructor(promiseFunc: () => Promise<T>, cacheKey?: string) {\n    this.promiseFunc = promiseFunc;\n    this.cacheKey = cacheKey ?? this.generateCacheKey();\n  }\n\n  /**\n   * 调用get方法，执行异步任务，缓存存在时会取缓存，如果有并发任务时，会等待上一个并发任务结束再取缓存\n   */\n  get = (): Promise<T> => {\n    if (!this.cacheKey || typeof this.promiseFunc !== 'function') {\n      const paramsError = new Error('cacheKey or promiseFunc can not be empty');\n      if (__DEV__) {\n        console.error(paramsError);\n      }\n      return Promise.reject(paramsError);\n    }\n    if (statusMap.has(this.cacheKey)) {\n      const currentStatus = statusMap.get(this.cacheKey);\n\n      // 判断当前的接口缓存状态，如果是 complete ，则代表缓存完成\n      if (currentStatus === 'complete') {\n        return Promise.resolve(cacheMap.get(this.cacheKey) as T);\n      }\n\n      // 如果是 pending ，则代表正在请求中，这里放入回调函数\n      if (currentStatus === 'pending') {\n        return new Promise((resolve, reject) => {\n          if (callbackMap.has(this.cacheKey)) {\n            callbackMap.get(this.cacheKey)!.push({\n              onSuccess: resolve,\n              onError: reject\n            });\n          } else {\n            callbackMap.set(this.cacheKey, [\n              {\n                onSuccess: resolve,\n                onError: reject\n              }\n            ]);\n          }\n        });\n      }\n    }\n\n    statusMap.set(this.cacheKey, 'pending');\n\n    return this.promiseFunc().then(\n      res => {\n        statusMap.set(this.cacheKey, 'complete');\n        cacheMap.set(this.cacheKey, res as any);\n        // 触发resolve的回调函数\n        if (callbackMap.has(this.cacheKey)) {\n          callbackMap.get(this.cacheKey)!.forEach(callback => {\n            callback.onSuccess(res);\n          });\n          // 调用完成之后清掉，用不到了\n          callbackMap.delete(this.cacheKey);\n        }\n        return res;\n      },\n      error => {\n        // 不成功的情况下删掉 statusMap 中的状态，能让下次请求重新请求\n        statusMap.delete(this.cacheKey);\n        // 这里触发reject的回调函数\n        if (callbackMap.has(this.cacheKey)) {\n          callbackMap.get(this.cacheKey)!.forEach(callback => {\n            callback.onError(error);\n          });\n          // 调用完成之后也清掉\n          callbackMap.delete(this.cacheKey);\n        }\n        // 返回 Promise.reject(error)，才能被catch捕捉到\n        return Promise.reject(error);\n      }\n    );\n  };\n\n  /**\n   * 获取缓存key\n   */\n  getCacheKey = () => {\n    return this.cacheKey;\n  };\n\n  /**\n   * 清空缓存\n   */\n  clearCache = () => {\n    if (!this.cacheKey) return;\n    callbackMap.delete(this.cacheKey);\n    statusMap.delete(this.cacheKey);\n    cacheMap.delete(this.cacheKey);\n  };\n\n  /**\n   * 手动强制执行异步任务-刷新缓存\n   */\n  forceUpdate = (): Promise<T> => {\n    this.clearCache();\n    return this.get();\n  };\n}\n\nexport default CachePromise;\n"],"names":["callbackMap","Map","statusMap","cacheMap","CachePromise","promiseFunc","cacheKey","this","_this","paramsError","Error","Promise","reject","has","currentStatus","get","resolve","push","onSuccess","onError","set","then","res","forEach","callback","error","clearCache","generateCacheKey","prototype","timestamp","Date","getTime","perforNow","performance","now","replace","c","random","Math","floor","toString","clear"],"mappings":"oEAGO,ICIDA,EAAc,IAAIC,IAGlBC,EAAY,IAAID,IAGhBE,EAAW,IAAIF,+BAgCnB,SAAAG,EAAYC,EAA+BC,cAQ3CC,SAAM,WACJ,IAAKC,EAAKF,UAAwC,mBAArBE,EAAKH,YAA4B,CAC5D,IAAMI,EAAc,IAAIC,MAAM,4CAI9B,OAAOC,QAAQC,OAAOH,GAExB,GAAIP,EAAUW,IAAIL,EAAKF,UAAW,CAChC,IAAMQ,EAAgBZ,EAAUa,IAAIP,EAAKF,UAGzC,GAAsB,aAAlBQ,EACF,OAAOH,QAAQK,QAAQb,EAASY,IAAIP,EAAKF,WAI3C,GAAsB,YAAlBQ,EACF,OAAO,IAAIH,SAAQ,SAACK,EAASJ,GACvBZ,EAAYa,IAAIL,EAAKF,UACvBN,EAAYe,IAAIP,EAAKF,UAAWW,KAAK,CACnCC,UAAWF,EACXG,QAASP,IAGXZ,EAAYoB,IAAIZ,EAAKF,SAAU,CAC7B,CACEY,UAAWF,EACXG,QAASP,QAUrB,OAFAV,EAAUkB,IAAIZ,EAAKF,SAAU,WAEtBE,EAAKH,cAAcgB,MACxB,SAAAC,GAWE,OAVApB,EAAUkB,IAAIZ,EAAKF,SAAU,YAC7BH,EAASiB,IAAIZ,EAAKF,SAAUgB,GAExBtB,EAAYa,IAAIL,EAAKF,YACvBN,EAAYe,IAAIP,EAAKF,UAAWiB,SAAQ,SAAAC,GACtCA,EAASN,UAAUI,MAGrBtB,SAAmBQ,EAAKF,WAEnBgB,KAET,SAAAG,GAYE,OAVAvB,SAAiBM,EAAKF,UAElBN,EAAYa,IAAIL,EAAKF,YACvBN,EAAYe,IAAIP,EAAKF,UAAWiB,SAAQ,SAAAC,GACtCA,EAASL,QAAQM,MAGnBzB,SAAmBQ,EAAKF,WAGnBK,QAAQC,OAAOa,OAQ5BlB,iBAAc,WACZ,OAAOC,EAAKF,UAMdC,gBAAa,WACNC,EAAKF,WACVN,SAAmBQ,EAAKF,UACxBJ,SAAiBM,EAAKF,UACtBH,SAAgBK,EAAKF,YAMvBC,iBAAc,WAEZ,OADAC,EAAKkB,aACElB,EAAKO,OAlGZR,KAAKF,YAAcA,EACnBE,KAAKD,eAAWA,EAAAA,EAAYC,KAAKoB,mBAVlC,OAWAvB,EAAAwB,UA5BOD,iBAAA,WACN,ODjBEE,GAAY,IAAIC,MAAOC,UACvBC,EACsB,oBAAhBC,aACNA,YAAYC,KACQ,IAApBD,YAAYC,OACd,EACK,uCAAuCC,QAAQ,SAAS,SAAAC,GAC7D,IAAIC,EAAyB,GAAhBC,KAAKD,SAQlB,OAPIR,EAAY,GACdQ,GAAUR,EAAYQ,GAAU,GAAK,EACrCR,EAAYS,KAAKC,MAAMV,EAAY,MAEnCQ,GAAUL,EAAYK,GAAU,GAAK,EACrCL,EAAYM,KAAKC,MAAMP,EAAY,MAEvB,MAANI,EAAYC,EAAmB,EAATA,EAAgB,GAAKG,SAAS,OAhBpC,IACtBX,EACAG,GCmBJ5B,EAGOsB,WAAP,SAAkBpB,GACA,MAAZA,GACFN,EAAYyC,QACZvC,EAAUuC,QACVtC,EAASsC,UAETzC,SAAmBM,GACnBJ,SAAiBI,GACjBH,SAAgBG,KAEnBF"}